package me.tymefly.beep.io;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.nio.charset.StandardCharsets;

import javax.annotation.Nonnull;

import me.tymefly.beep.config.CliParser;
import me.tymefly.beep.utils.Preconditions;



/**
 * Driver that talks to the Programmer
 */
public class ProgrammerDriver {
    /** Maximum number of bytes that can be sent to the programmer in one go */
    public static final int BUFFER_SIZE = 60;

    /** Response generated by the programmer when it is ready for a new command */
    public static final String PROMPT = "+ Ready";

    /** Response generated by the programmer if a command failed */
    public static final String FAIL = "ERROR";

    private static final int POLL_TIME_MS = 50;
    private static final int WRITE_DELAY_MS = 250;              // programmer delay so it knows the data has finished

    private static final ProgrammerDriver INSTANCE = new ProgrammerDriver();
    private boolean isOpen;
    private ComPort port;                                      // Only accessed via getPort


    private ProgrammerDriver() {
        isOpen = true;
    }


    /**
     * Returns the singleton instance of this driver
     * @return the singleton instance of this driver
     */
    @Nonnull
    public static ProgrammerDriver getInstance() {
        return INSTANCE;
    }


    /**
     * Send a command to the programmer
     * @param command       Command to send
     * @throws IllegalArgumentException if the length of the command exceeds {@link #BUFFER_SIZE}
     */
    public void sendCommand(@Nonnull String command) throws IllegalArgumentException {
        Preconditions.checkState(isOpen, "Driver has been closed");

        sendData(command.getBytes(StandardCharsets.US_ASCII));
    }


    /**
     * Sends all the data in the array to the programmer
     * @param bytes     Data to send
     * @throws IllegalArgumentException if {@code bytes.length} exceeds {@link #BUFFER_SIZE}
     */
    private void sendData(byte[] bytes) throws IllegalArgumentException {
        Preconditions.checkState(isOpen, "Driver has been closed");

        sendData(bytes, 0, bytes.length);
    }


    /**
     * Send some binary data to the programmer
     * @param bytes     Data to send to the programmer
     * @param offset    Offset in the buffer of the first byte to send
     * @param length    The number of bytes to send.
     * @throws IllegalArgumentException if {@code length} exceeds {@link #BUFFER_SIZE}
     */
    public void sendData(byte[] bytes, int offset, int length) throws IllegalArgumentException {
        Preconditions.checkState(isOpen, "Driver has been closed");
        Preconditions.checkArgument((length <= BUFFER_SIZE), "Buffer overrun. %d bytes sent", length);

        try (OutputStream out = getPort().getOutputStream()) {
            out.write(bytes, offset, length);

            Thread.sleep(WRITE_DELAY_MS);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }


    /**
     * Read a single string from the programmer
     * @return A string the programmer sent.
     */
    @Nonnull
    public String readLine() {
        Preconditions.checkState(isOpen, "Driver has been closed");

        StringBuilder line = new StringBuilder();
        byte[] buffer = new byte[1];
        boolean timeOut = false;

        try (
            InputStream in = getPort().getInputStream()
        ) {
            boolean done = false;

            while (!done) {
                timeOut = !waitForData(in);

                int read = in.read(buffer);

                if (read == 1) {
                    char data = (char) buffer[0];
                    done = (data == '\n');

                    if (!done && (data >= ' ')) {
                        line.append(data);
                    }
                } else {
                    timeOut = true;
                }

                done |= timeOut;
            }
        } catch (Exception e) {
            throw new DriverException("Failed to read COM port", e);
        }

        if (timeOut) {
            throw new RuntimeException("timeout reading COM port");
        }

        return line.toString();
    }


    private void gobble(@Nonnull InputStream in) throws IOException {
        while (in.available() != 0) {
            int read = in.read();

            if (read == 0) {
                throw new DriverException("Failed to read data from COM port");
            }
        }
    }


    /**
     * Write the programmer response to {@link System#out}
     */
    public void dumpResponse() {
        Preconditions.checkState(isOpen, "Driver has been closed");

        dumpResponse(System.out);
    }


    private boolean dumpResponse(@Nonnull PrintStream out) {
        byte[] buffer = new byte[1];
        int index = 0;
        boolean timeOut = false;

        try (
            InputStream in = getPort().getInputStream()
        ) {
            boolean done = false;
            while (!done) {
                timeOut = !waitForData(in);

                int read = in.read(buffer);

                if (read == 1) {
                    char data = (char) buffer[0];

                    if (PROMPT.charAt(index) == data) {
                        done = (++index == PROMPT.length());
                    } else if (index == 0) {
                        out.print(data);
                    } else {
                        out.print(PROMPT.substring(0, index));
                        out.print(data);
                        index = 0;
                    }
                } else {
                    timeOut = true;
                }

                done |= timeOut;
            }

            gobble(in);
        } catch (Exception e) {
            throw new DriverException("Failed to read COM port", e);
        }

        return !timeOut;
    }


    /**
     * Wait for the programmer to respond
     * @return {@literal true} only if data has been sent by the programmer
     */
    private static boolean waitForData(@Nonnull InputStream in) throws IOException {
        int available = in.available();
        long finishAt = System.currentTimeMillis() + CliParser.getInstance().getProgrammerTimeoutMs();

        while ((available == 0) && (System.currentTimeMillis() <= finishAt)) {
            try {
                Thread.sleep(POLL_TIME_MS);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }

            available = in.available();
        }

        return (available != 0);
    }


    @Nonnull
    private ComPort getPort() {
        if (port == null) {
            port = new ComPort();

            boolean sync = dumpResponse(new PrintStream(new NullOutputStream()));

            if (!sync) {
                throw new DriverException("Programmer failed to respond");
            }
        }

        return port;
    }


    /**
     * Close the programmer. No further operations are valid
     */
    public void close() {
        if (port != null) {
            port.close();

            port = null;
        }

        isOpen = false;
    }
}
